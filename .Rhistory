)
# Recodage simple
data_clean$estimateur <- recode(data_clean$estimateur,
HT_multi            = noms_estimateurs[1],
HT_mono             = noms_estimateurs[2],
multimode_expansion = noms_estimateurs[3],
monomode_expansion  = noms_estimateurs[4],
`1a`                = noms_estimateurs[5],
`1aprime`           = noms_estimateurs[6],
`1b`                = noms_estimateurs[7],
`2a`                = noms_estimateurs[8],
`2aprime`           = noms_estimateurs[9],
`3`                 = noms_estimateurs[10],
`3prime`            = noms_estimateurs[11],
`3a`                = noms_estimateurs[12],
`3aprime`           = noms_estimateurs[13],
`3b`                = noms_estimateurs[14],
`3bprime`           = noms_estimateurs[15],
`4`                 = noms_estimateurs[16]
)
# Filtrage spécifique pour le graphique EQM et ajustement des levels
if (type_graphique == "eqm" && any(c("3a", "3b") %in% nom_methodes)) {
estimateurs_a_exclure <- c(
"Bankier avec indépendance des tirages (3)",
"Bankier avec indépendance et CNR après (3a)",
"Bankier avec indépendance et CNR avant (3b)"
)
data_clean <- data_clean %>%
filter(!estimateur %in% estimateurs_a_exclure)
# Ajuster les levels pour ne garder que ceux présents dans les données, dans le bon ordre
noms_estimateurs_filtres <- noms_estimateurs[!noms_estimateurs %in% estimateurs_a_exclure]
data_clean$estimateur <- factor(data_clean$estimateur, levels = noms_estimateurs_filtres)
} else {
# Facteur ordonné avec tous les estimateurs
data_clean$estimateur <- factor(data_clean$estimateur, levels = noms_estimateurs)
}
# Choix variable et label selon type_graphique
if (type_graphique == "boxplots") {
var_to_plot <- "biais_relatif"
y_label <- paste0(
"\n\nIntervalles interquartiles et moyennes empiriques des\n",
"biais relatifs exprimés en % sur les résultats de ", nb_sim, " simulations"
)
# Calcul des quantiles uniquement si nécessaire
need_q25 <- is.null(xmin_boxplots)
need_q75 <- is.null(xmax_boxplots)
if (need_q25 || need_q75) {
quantiles <- data_clean %>%
group_by(methode, y, estimateur, ensemble) %>%
summarise(
q25 = quantile(biais_relatif, 0.25, na.rm = TRUE),
q75 = quantile(biais_relatif, 0.75, na.rm = TRUE),
.groups = "drop"
)
}
xmin <- if (is.null(xmin_boxplots)) {
floor(min(quantiles$q25, na.rm = TRUE) * 2) / 2
} else {
xmin_boxplots
}
xmax <- if (is.null(xmax_boxplots)) {
ceiling(max(quantiles$q75, na.rm = TRUE) * 2) / 2
} else {
xmax_boxplots
}
} else if (type_graphique == "biais") {
var_to_plot <- "biais_relatif_abs"
y_label <- paste0("\n\nBiais relatifs absolus exprimés en % sur les résultats de ", nb_sim, " simulations")
xmin <- 0
if (is.null(xmax_biais)) {
xmax <- max(data_clean[[var_to_plot]], na.rm = TRUE)
} else {
xmax <- xmax_biais
}
} else if (type_graphique == "eqm") {
var_to_plot <- "cv_reqm"
y_label <- paste0("\n\nCoefficients de variation de la REQM sur les résultats de ", nb_sim, " simulations")
xmin <- 0
if (is.null(xmax_eqm)) {
xmax <- max(data_clean[[var_to_plot]], na.rm = TRUE)
} else {
xmax <- xmax_eqm
}
} else {
stop("type_graphique doit être 'boxplots', 'biais' ou 'eqm'")
}
data_clean$ensemble <- factor(
data_clean$ensemble,
levels = rev(levels(data_clean$ensemble))
)
create_plot <- function(data) {
data <- data %>%
mutate(
estimateur = fct_rev(droplevels(estimateur))
)
old_warn <- getOption("warn")
options(warn = -1)
if (type_graphique == "boxplots") {
p <- suppressWarnings({
data %>%
ggplot(aes(x = !!sym(var_to_plot), y = estimateur, fill = ensemble)) +
geom_boxplot(
width = 0.4,
position = position_dodge(width = 0.65),
outlier.shape = NA,
coef = 0,
color = "black",
linewidth = 0.325,
fatten = NULL
) +
stat_summary(
fun = mean,
geom = "point",
shape = 16,
size = 1,
color = "black",
position = position_dodge(width = 0.65)
) +
geom_vline(xintercept = 0, linetype = "solid", color = "black", linewidth = 0.45)
})
} else {
p <- data %>%
ggplot(aes(x = !!sym(var_to_plot), y = estimateur, fill = ensemble)) +
geom_col(
width = 0.4,
position = position_dodge(width = 0.65),
color = "black",
linewidth = 0.325
) +
geom_vline(xintercept = 0, linetype = "solid", color = "black", linewidth = 0.45)
}
p <- p +
facet_grid(rows = vars(methode_vertical), cols = vars(y), scales = "free_y") +
coord_cartesian(xlim = c(xmin, xmax)) +
scale_fill_manual(
values = c(
"France " = "#5D6D7E",
"Hors Île-de-France " = "#A9DFBF",
"Île-de-France" = "#E74C3C"
),
breaks = c("France ", "Hors Île-de-France ", "Île-de-France"),
guide = guide_legend(reverse = FALSE)
) +
theme(
strip.text.y = element_text(lineheight = 0.9, size = 14, face = "bold", color = "black", hjust = 0.5, vjust = 0.5, angle = 0),
strip.text.x = element_markdown(size = 14, face = "bold", color = "black", margin = margin(b = 2, t = 5)),
strip.background = element_rect(fill = "#AFAFAF"),
axis.text.y = element_text(size = 12),  # légèrement augmenté
axis.text.x = element_text(size = 14),  # légèrement augmenté
axis.title.y = element_blank(),        # supprime le titre de l'axe y
axis.title.x = element_blank(),
legend.text = element_text(size = 14),  # augmente taille des labels de légende
legend.position = "bottom",
legend.title = element_blank(),
legend.spacing.x = unit(0.7, "cm"),
plot.margin = margin(0, 0, 0, 0)
) +
labs(
x = y_label
)
return(p)
}
pdf.options(encoding = "UTF-8")
if (type_graphique == "boxplots") {
# complet
p_all <- create_plot(data_clean)
ggsave(
filename = paste0(chemin_sous_dossier, "/2-boxplots-complet_", nom_dossier, "_scenario_", sc, ".pdf"),
plot = p_all, device = cairo_pdf, width = 11, height = 15.5, units = "in"
)
# page1
p_page1 <- create_plot(filter(data_clean, methode_label %in% methode_labels[c("sans_nr", "cnr_exacte")]))
ggsave(
filename = paste0(chemin_sous_dossier, "/2-boxplots-page1_", nom_dossier, "_scenario_", sc, ".pdf"),
plot = p_page1, device = cairo_pdf, width = 11, height = 8, units = "in"
)
# page2
p_page2 <- create_plot(filter(data_clean, methode_label %in% methode_labels[c("sans_grh", "avec_grh")]))
ggsave(
filename = paste0(chemin_sous_dossier, "/2-boxplots-page2_", nom_dossier, "_scenario_", sc, ".pdf"),
plot = p_page2, device = cairo_pdf, width = 11, height = 8, units = "in"
)
} else if (type_graphique == "biais") {
# complet
p_all <- create_plot(data_clean)
ggsave(
filename = paste0(chemin_sous_dossier, "/3-biais-complet_", nom_dossier, "_scenario_", sc, ".pdf"),
plot = p_all, device = cairo_pdf, width = 11, height = 15.5, units = "in"
)
# page1
p_page1 <- create_plot(filter(data_clean, methode_label %in% methode_labels[c("sans_nr", "cnr_exacte")]))
ggsave(
filename = paste0(chemin_sous_dossier, "/3-biais-page1_", nom_dossier, "_scenario_", sc, ".pdf"),
plot = p_page1, device = cairo_pdf, width = 13, height = 8, units = "in"
)
# page2
p_page2 <- create_plot(filter(data_clean, methode_label %in% methode_labels[c("sans_grh", "avec_grh")]))
ggsave(
filename = paste0(chemin_sous_dossier, "/3-biais-page2_", nom_dossier, "_scenario_", sc, ".pdf"),
plot = p_page2, device = cairo_pdf, width = 13, height = 8, units = "in"
)
} else if (type_graphique == "eqm") {
# uniquement page2
p_page2 <- create_plot(filter(data_clean, methode_label %in% methode_labels[c("sans_grh", "avec_grh")]))
ggsave(
filename = paste0(chemin_sous_dossier, "/4-eqm-page2_", nom_dossier, "_scenario_", sc, ".pdf"),
plot = p_page2, device = cairo_pdf, width = 13, height = 8, units = "in"
)
} else {
stop("type_graphique doit être 'boxplots', 'biais' ou 'eqm'")
}
}
# Appels dynamiques des fonctions de post-traitement pour chaque scénario
for (sc in scenarios_nr) {
num_sous_dossier <- 4 + as.integer(sc) - 1
chemin_sous_dossier <- paste0(chemin_dossier, "/", "D", num_dossier, ".", num_sous_dossier, "-graphiques_scenario_", sc)
dir.create(chemin_sous_dossier, recursive = TRUE, showWarnings = FALSE)
# Récupération des objets
obj_biais <- get(paste0(nom_dossier, "_biais"), envir = .GlobalEnv)
obj_brut <- get(paste0(nom_dossier, "_brut"), envir = .GlobalEnv)
obj_taux <- get(paste0(nom_dossier, "_taux_rep_grh"), envir = .GlobalEnv)
# Graphiques et tableau
tableau_resultats(obj_brut, nom_dossier, num_dossier, sc, chemin_sous_dossier)
graphique_principal(obj_biais, nb_sim, nom_methodes, nom_dossier, num_dossier, sc, chemin_sous_dossier, "boxplots")
graphique_principal(obj_biais, nb_sim, nom_methodes, nom_dossier, num_dossier, sc, chemin_sous_dossier, "biais")
graphique_principal(obj_biais, nb_sim, nom_methodes, nom_dossier, num_dossier, sc, chemin_sous_dossier, "eqm")
taux_rep_grh(obj_taux, nb_sim, nom_dossier, num_dossier, sc, chemin_sous_dossier)
comparaisons_coef_hartley(obj_biais, n_multi, n_mono) # à faire que pour une grosse simulation
# Nettoyage
rm(obj_biais, obj_brut, obj_taux)
cat(paste0(
"\nTous les tableaux et figures du scénario ", sc ," ont bien été exportés dans le dossier correspondant.\n"))
}
View(test_biais)
source("B-outils/B1-tirage/B1.5-tirage.R")
source("B-outils/B2-correction_non_reponse/B2.3-cnr_finale.R")
source("B-outils/B4-estimations/B4.4-boucles_simulations.R")
source("B-outils/B5-export_import/B5.1-export_resultats.R")
source("B-outils/B5-export_import/B5.2-lire_resultats.R")
source("B-outils/B6-tableaux_figures/B6.1-tableau_resultats.R")
source("B-outils/B6-tableaux_figures/B6.2-graphique_principal.R")
source("B-outils/B6-tableaux_figures/B6.3-taux_rep_grh.R")
source("B-outils/B6-tableaux_figures/B6.4-comparaisons_coef_hartley.R")
nb_sim <- 20
nb_sim <- 5
n_multi <- 30800
part_idf_multimode <- 0.148
n_mono <- 50000
part_idf_monomode <- 0.49562
grh <- 20
taux_min_grh = 0.1
scenarios_nr <- c("1", "2", "3", "4")
prefix_var_interet <- c("y_1_", "y_2_", "y_3_")
nom_methodes <- c("1a", "1aprime", "1b", "2a", "2aprime", "3a", "3aprime", "3b", "3bprime", "4", "4A", "4B")
formule_cnr = "x_1 + x_2 + x_3 + x_4 + x_5"
strat_var_name = "strate_vec"
resultats <- boucles_simulations(
nb_sim = nb_sim,
bdd = bdd,
nom_methodes = nom_methodes,
n_multi = n_multi,
n_mono = n_mono,
part_strate_A_dans_mode_1 = 1 - part_idf_multimode,
part_strate_A_dans_mode_2 = 1 - part_idf_monomode,
scenarios = scenarios_nr,
prefix_var_interet = prefix_var_interet,
strat_var_name = strat_var_name,
sigma = sigma_1,
modele_latent = TRUE,
formule_cnr = formule_cnr,
grh = grh,
taux_min_grh = taux_min_grh,
parallel = FALSE, # à mettre que si nb_sim est grand, sinon faire séquentiellement (parallel = FALSE) est plus efficace
n_cores = 16,
batch_size = 16
)
nom_dossier <- "test"
num_dossier <- "0"
# Créer le dossier s’il n’existe pas
chemin_dossier <- paste0("D-exports/D", num_dossier, "-", nom_dossier)
dir.create(chemin_dossier, recursive = TRUE, showWarnings = FALSE)
# Sauvegarde
export_resultats(resultats, num_dossier, chemin_dossier, nom_dossier)
# Réimportation des résultats dans l'environnement de travail
lire_resultats(num_dossier, nom_dossier, chemin_dossier, scenarios_nr, nom_methodes, prefix_var_interet, nb_sim)
# Appels dynamiques des fonctions de post-traitement pour chaque scénario
for (sc in scenarios_nr) {
num_sous_dossier <- 4 + as.integer(sc) - 1
chemin_sous_dossier <- paste0(chemin_dossier, "/", "D", num_dossier, ".", num_sous_dossier, "-graphiques_scenario_", sc)
dir.create(chemin_sous_dossier, recursive = TRUE, showWarnings = FALSE)
# Récupération des objets
obj_biais <- get(paste0(nom_dossier, "_biais"), envir = .GlobalEnv)
obj_brut <- get(paste0(nom_dossier, "_brut"), envir = .GlobalEnv)
obj_taux <- get(paste0(nom_dossier, "_taux_rep_grh"), envir = .GlobalEnv)
# Graphiques et tableau
tableau_resultats(obj_brut, nom_dossier, num_dossier, sc, chemin_sous_dossier)
graphique_principal(obj_biais, nb_sim, nom_methodes, nom_dossier, num_dossier, sc, chemin_sous_dossier, "boxplots")
graphique_principal(obj_biais, nb_sim, nom_methodes, nom_dossier, num_dossier, sc, chemin_sous_dossier, "biais")
graphique_principal(obj_biais, nb_sim, nom_methodes, nom_dossier, num_dossier, sc, chemin_sous_dossier, "eqm")
taux_rep_grh(obj_taux, nb_sim, nom_dossier, num_dossier, sc, chemin_sous_dossier)
comparaisons_coef_hartley(obj_biais, n_multi, n_mono) # à faire que pour une grosse simulation
# Nettoyage
rm(obj_biais, obj_brut, obj_taux)
cat(paste0(
"\nTous les tableaux et figures du scénario ", sc ," ont bien été exportés dans le dossier correspondant.\n"))
}
# Appels dynamiques des fonctions de post-traitement pour chaque scénario
for (sc in scenarios_nr) {
num_sous_dossier <- 4 + as.integer(sc) - 1
chemin_sous_dossier <- paste0(chemin_dossier, "/", "D", num_dossier, ".", num_sous_dossier, "-graphiques_scenario_", sc)
dir.create(chemin_sous_dossier, recursive = TRUE, showWarnings = FALSE)
# Récupération des objets
obj_biais <- get(paste0(nom_dossier, "_biais"), envir = .GlobalEnv)
obj_brut <- get(paste0(nom_dossier, "_brut"), envir = .GlobalEnv)
obj_taux <- get(paste0(nom_dossier, "_taux_rep_grh"), envir = .GlobalEnv)
# Graphiques et tableau
tableau_resultats(obj_brut, nom_dossier, num_dossier, sc, chemin_sous_dossier)
graphique_principal(obj_biais, nb_sim, nom_methodes, nom_dossier, num_dossier, sc, chemin_sous_dossier, "boxplots")
graphique_principal(obj_biais, nb_sim, nom_methodes, nom_dossier, num_dossier, sc, chemin_sous_dossier, "biais")
graphique_principal(obj_biais, nb_sim, nom_methodes, nom_dossier, num_dossier, sc, chemin_sous_dossier, "eqm")
taux_rep_grh(obj_taux, nb_sim, nom_dossier, num_dossier, sc, chemin_sous_dossier)
# comparaisons_coef_hartley(obj_biais, n_multi, n_mono) # à faire que pour une grosse simulation
# Nettoyage
rm(obj_biais, obj_brut, obj_taux)
cat(paste0(
"\nTous les tableaux et figures du scénario ", sc ," ont bien été exportés dans le dossier correspondant.\n"))
}
View(test_biais)
source("B-outils/B1-tirage/B1.5-tirage.R")
source("B-outils/B2-correction_non_reponse/B2.3-cnr_finale.R")
source("B-outils/B4-estimations/B4.4-boucles_simulations.R")
source("B-outils/B5-export_import/B5.1-export_resultats.R")
source("B-outils/B5-export_import/B5.2-lire_resultats.R")
source("B-outils/B6-tableaux_figures/B6.1-tableau_resultats.R")
source("B-outils/B6-tableaux_figures/B6.2-graphique_principal.R")
source("B-outils/B6-tableaux_figures/B6.3-taux_rep_grh.R")
source("B-outils/B6-tableaux_figures/B6.4-comparaisons_coef_hartley.R")
nb_sim <- 1
n_multi <- 30800
part_idf_multimode <- 0.148
n_mono <- 50000
part_idf_monomode <- 0.49562
grh <- 20
taux_min_grh = 0.1
scenarios_nr <- c("1", "2", "3", "4")
prefix_var_interet <- c("y_1_", "y_2_", "y_3_")
nom_methodes <- c("1a", "1aprime", "1b", "2a", "2aprime", "3a", "3aprime", "3b", "3bprime", "4")
formule_cnr = "x_1 + x_2 + x_3 + x_4 + x_5"
strat_var_name = "strate_vec"
resultats <- boucles_simulations(
nb_sim = nb_sim,
bdd = bdd,
nom_methodes = nom_methodes,
n_multi = n_multi,
n_mono = n_mono,
part_strate_A_dans_mode_1 = 1 - part_idf_multimode,
part_strate_A_dans_mode_2 = 1 - part_idf_monomode,
scenarios = scenarios_nr,
prefix_var_interet = prefix_var_interet,
strat_var_name = strat_var_name,
sigma = sigma_1,
modele_latent = TRUE,
formule_cnr = formule_cnr,
grh = grh,
taux_min_grh = taux_min_grh,
parallel = FALSE, # à mettre que si nb_sim est grand, sinon faire séquentiellement (parallel = FALSE) est plus efficace
n_cores = 16,
batch_size = 16
)
nom_dossier <- "test"
num_dossier <- "0"
# Créer le dossier s’il n’existe pas
chemin_dossier <- paste0("D-exports/D", num_dossier, "-", nom_dossier)
dir.create(chemin_dossier, recursive = TRUE, showWarnings = FALSE)
# Sauvegarde
export_resultats(resultats, num_dossier, chemin_dossier, nom_dossier)
# Réimportation des résultats dans l'environnement de travail
lire_resultats(num_dossier, nom_dossier, chemin_dossier, scenarios_nr, nom_methodes, prefix_var_interet, nb_sim)
# Appels dynamiques des fonctions de post-traitement pour chaque scénario
for (sc in scenarios_nr) {
num_sous_dossier <- 4 + as.integer(sc) - 1
chemin_sous_dossier <- paste0(chemin_dossier, "/", "D", num_dossier, ".", num_sous_dossier, "-graphiques_scenario_", sc)
dir.create(chemin_sous_dossier, recursive = TRUE, showWarnings = FALSE)
# Récupération des objets
obj_biais <- get(paste0(nom_dossier, "_biais"), envir = .GlobalEnv)
obj_brut <- get(paste0(nom_dossier, "_brut"), envir = .GlobalEnv)
obj_taux <- get(paste0(nom_dossier, "_taux_rep_grh"), envir = .GlobalEnv)
# Graphiques et tableau
tableau_resultats(obj_brut, nom_dossier, num_dossier, sc, chemin_sous_dossier)
graphique_principal(obj_biais, nb_sim, nom_methodes, nom_dossier, num_dossier, sc, chemin_sous_dossier, "boxplots")
graphique_principal(obj_biais, nb_sim, nom_methodes, nom_dossier, num_dossier, sc, chemin_sous_dossier, "biais")
graphique_principal(obj_biais, nb_sim, nom_methodes, nom_dossier, num_dossier, sc, chemin_sous_dossier, "eqm")
taux_rep_grh(obj_taux, nb_sim, nom_dossier, num_dossier, sc, chemin_sous_dossier)
comparaisons_coef_hartley(obj_biais, n_multi, n_mono) # à faire que pour une grosse simulation
# Nettoyage
rm(obj_biais, obj_brut, obj_taux)
cat(paste0(
"\nTous les tableaux et figures du scénario ", sc ," ont bien été exportés dans le dossier correspondant.\n"))
}
nb_sim <- 1000
n_multi <- 30800
part_idf_multimode <- 0.148
n_mono <- 50000
part_idf_monomode <- 0.49562
grh <- 20
taux_min_grh = 0.1
scenarios_nr <- c("1", "2", "3", "4")
prefix_var_interet <- c("y_1_", "y_2_", "y_3_")
nom_methodes <- c("1a", "1aprime", "1b", "2a", "2aprime", "3a", "3aprime", "3b", "3bprime", "4")
formule_cnr = "x_1 + x_2 + x_3 + x_4 + x_5"
strat_var_name = "strate_vec"
resultats <- boucles_simulations(
nb_sim = nb_sim,
bdd = bdd,
nom_methodes = nom_methodes,
n_multi = n_multi,
n_mono = n_mono,
part_strate_A_dans_mode_1 = 1 - part_idf_multimode,
part_strate_A_dans_mode_2 = 1 - part_idf_monomode,
scenarios = scenarios_nr,
prefix_var_interet = prefix_var_interet,
strat_var_name = strat_var_name,
sigma = sigma_1,
modele_latent = TRUE,
formule_cnr = formule_cnr,
grh = grh,
taux_min_grh = taux_min_grh,
parallel = FALSE, # à mettre que si nb_sim est grand, sinon faire séquentiellement (parallel = FALSE) est plus efficace
n_cores = 16,
batch_size = 16
)
resultats <- boucles_simulations(
nb_sim = nb_sim,
bdd = bdd,
nom_methodes = nom_methodes,
n_multi = n_multi,
n_mono = n_mono,
part_strate_A_dans_mode_1 = 1 - part_idf_multimode,
part_strate_A_dans_mode_2 = 1 - part_idf_monomode,
scenarios = scenarios_nr,
prefix_var_interet = prefix_var_interet,
strat_var_name = strat_var_name,
sigma = sigma_1,
modele_latent = TRUE,
formule_cnr = formule_cnr,
grh = grh,
taux_min_grh = taux_min_grh,
parallel = TRUE, # à mettre que si nb_sim est grand, sinon faire séquentiellement (parallel = FALSE) est plus efficace
n_cores = 16,
batch_size = 16
)
nb_sim <- 100
resultats <- boucles_simulations(
nb_sim = nb_sim,
bdd = bdd,
nom_methodes = nom_methodes,
n_multi = n_multi,
n_mono = n_mono,
part_strate_A_dans_mode_1 = 1 - part_idf_multimode,
part_strate_A_dans_mode_2 = 1 - part_idf_monomode,
scenarios = scenarios_nr,
prefix_var_interet = prefix_var_interet,
strat_var_name = strat_var_name,
sigma = sigma_1,
modele_latent = TRUE,
formule_cnr = formule_cnr,
grh = grh,
taux_min_grh = taux_min_grh,
parallel = TRUE, # à mettre que si nb_sim est grand, sinon faire séquentiellement (parallel = FALSE) est plus efficace
n_cores = 16,
batch_size = 16
)
resultats <- boucles_simulations(
nb_sim = nb_sim,
bdd = bdd,
nom_methodes = nom_methodes,
n_multi = n_multi,
n_mono = n_mono,
part_strate_A_dans_mode_1 = 1 - part_idf_multimode,
part_strate_A_dans_mode_2 = 1 - part_idf_monomode,
scenarios = scenarios_nr,
prefix_var_interet = prefix_var_interet,
strat_var_name = strat_var_name,
sigma = sigma_1,
modele_latent = TRUE,
formule_cnr = formule_cnr,
grh = grh,
taux_min_grh = taux_min_grh,
parallel = TRUE, # à mettre que si nb_sim est grand, sinon faire séquentiellement (parallel = FALSE) est plus efficace
n_cores = 8,
batch_size = 16
)
resultats <- boucles_simulations(
nb_sim = nb_sim,
bdd = bdd,
nom_methodes = nom_methodes,
n_multi = n_multi,
n_mono = n_mono,
part_strate_A_dans_mode_1 = 1 - part_idf_multimode,
part_strate_A_dans_mode_2 = 1 - part_idf_monomode,
scenarios = scenarios_nr,
prefix_var_interet = prefix_var_interet,
strat_var_name = strat_var_name,
sigma = sigma_1,
modele_latent = TRUE,
formule_cnr = formule_cnr,
grh = grh,
taux_min_grh = taux_min_grh,
parallel = TRUE, # à mettre que si nb_sim est grand, sinon faire séquentiellement (parallel = FALSE) est plus efficace
n_cores = 8,
batch_size = 16
)
